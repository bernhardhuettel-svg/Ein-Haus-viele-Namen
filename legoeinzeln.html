<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>3D Bungalow – mit Pool </title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body { margin:0; background:#eef2f3; font-family:system-ui; overflow:hidden; }
#container { width:100vw; height:100vh; }
</style>
</head>
<body>

<div id="container"></div>

//Z+
//
//      +6
//      ┌────────────┐
//      │            │
//      │    HAUS    │
//      │            │
//-6 ───└────────────┘─── +6   → X
//      0
//
//Z-

//Y  ↑   (Höhe)
//   |
//   |
//   └────→ X  (links / rechts)
//  /
// Z
//(vorne / hinten)
    
<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.158/build/three.module.js";

/* ===================== Grundwerte ===================== */
const houseWidth  = 12;
const houseDepth  = 12;
const houseHeight = 3;
const axes = new THREE.AxesHelper(10);

const container = document.getElementById("container");
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xcce6ff);
scene.add(axes);

/* ===================== Kamera ===================== */
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 500);
camera.position.set(30, 18, 30);

/* ===================== Renderer ===================== */
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
container.appendChild(renderer.domElement);

/* ===================== Licht ===================== */
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const sun = new THREE.DirectionalLight(0xffffff, 1);
sun.position.set(50,100,50);
scene.add(sun);

/* ===================== Materialien ===================== */
const matGround = new THREE.MeshStandardMaterial({color:0x7fa86c});
const matWall   = new THREE.MeshStandardMaterial({color:0xc7a17a});
const matRoof   = new THREE.MeshStandardMaterial({color:0x8b3e2f});
const matGlass  = new THREE.MeshStandardMaterial({color:0x99ccff, transparent:true, opacity:0.6});
const matWood   = new THREE.MeshStandardMaterial({color:0x4a2e1b});

/* ===================== Grundstück ===================== */
const ground = new THREE.Mesh(new THREE.PlaneGeometry(40,20), matGround);
ground.rotation.x = -Math.PI/2;
scene.add(ground);

/* ===================== Wände ===================== */
function wallBlocksArray(x0,z0,w,d,h){
    const blocks = [];
    const size = 0.4;
    const gap = 0.03;

    for(let x=0; x<w; x+=size+gap){
        for(let y=0; y<h; y+=size+gap){
            for(let z=0; z<d; z+=size+gap){
                const b = new THREE.Mesh(
                    new THREE.BoxGeometry(size,size,size),
                    matWall
                );
                b.position.set(x0 + x + size/2, y + size/2, z0 + z + size/2);
                blocks.push(b);
            }
        }
    }
    return blocks;
}

/* Block hinzufügen  */
const wallArray = wallBlocksArray(-6,-6,12,0.4,3);

let index = 0;
function addNextBlock(){
    if(index < wallArray.length){
        scene.add(wallArray[index]);
        index++;
        setTimeout(addNextBlock, 100); // alle 100ms ein Block
    }
}
addNextBlock();

//Erdgeschoss
const wallFrontArray  = wallBlocksArray(-6,5.6,12,0.4,3);
const wallBackArray   = wallBlocksArray(-6,-6,12,0.4,3);
const wallLeftArray   = wallBlocksArray(-6,-6,0.4,12,3);
const wallRightArray  = wallBlocksArray(5.6,-6,0.4,12,3);

// Animation starten, z. B. nacheinander
let arrays = [wallFrontArray, wallBackArray, wallLeftArray, wallRightArray];
let arrayIndex = 0;
function addNextWall(){
    if(arrayIndex < arrays.length){
        let blocks = arrays[arrayIndex];
        let i = 0;
        function addBlock(){
            if(i < blocks.length){
                scene.add(blocks[i]);
                i++;
                setTimeout(addBlock, 20);
            } else {
                arrayIndex++;
                addNextWall();
            }
        }
        addBlock();
    }
}
addNextWall();


/* ===================== Fenster ===================== */
function createWindow(xStart, yStart, zStart, width, height, depth = 0.2){
    const group = new THREE.Group();
    const size = 0.4;
    const gap = 0.05;
    for (let x = 0; x < width; x += size + gap){
        for (let y = 0; y < height; y += size + gap){
            const block = new THREE.Mesh(new THREE.BoxGeometry(size,size,depth), matGlass);
            block.position.set(xStart + x + size/2, yStart + y + size/2, zStart);
            group.add(block);
        }
    }
    scene.add(group);
}

// Fenster vorne
createWindow(-4, 1.2, 6.1, 2.4, 1.6);
createWindow( 1.6, 1.2, 6.1, 2.4, 1.6);


function createSlidingDoor(xStart, yStart, zStart, width, height, depth=0.2){
    const group = new THREE.Group();
    const size = 0.4;
    const gap = 0.05;

    for (let x = 0; x < width; x += size+gap){
        for (let y = 0; y < height; y += size+gap){
            const block = new THREE.Mesh(new THREE.BoxGeometry(size,size,depth), matGlass);
            block.position.set(xStart + x + size/2, yStart + y + size/2, zStart);
            group.add(block);
        }
    }
    return group;
}

// Beispiel rechte Hauswand
//slidingDoor.rotation.x = Math.PI / 2;     
const slidingDoor = createSlidingDoor(-5.7, 0.8, 6, 12, 3);
scene.add(slidingDoor);

    
/* ===================== Tür ===================== */
const door = new THREE.Mesh(new THREE.BoxGeometry(1.8,2.3,0.2), matWood);
door.position.set(0,1.15,6.1);
scene.add(door);

/* ===================== Walmdach ===================== */
function roofSlopeAllSides(width, depth, slope) {
    const size = 0.5;
    const gap = 0.05;
    const yOffset = 0.2;

    // VORNE
    const front = new THREE.Group();
    const frontZ = houseDepth / 2;
    for (let x=-width/2;x<width/2;x+=size+gap){
        for (let z=0; z<depth; z+=size+gap){
            const y = slope*z;
            const tile = new THREE.Mesh(new THREE.BoxGeometry(size, size*0.4, size), matRoof);
            tile.position.set(x, houseHeight + y + yOffset, frontZ - z);
            front.add(tile);
        }
    }
    scene.add(front);

    // HINTEN
    const back = new THREE.Group();
    const backZ = -houseDepth / 2;
    for (let x=-width/2;x<width/2;x+=size+gap){
        for (let z=0; z<depth; z+=size+gap){
            const y = slope*z;
            const tile = new THREE.Mesh(new THREE.BoxGeometry(size, size*0.4, size), matRoof);
            tile.position.set(x, houseHeight + y + yOffset, backZ + z);
            back.add(tile);
        }
    }
    scene.add(back);
}

// Dach aufsetzen
roofSlopeAllSides(houseWidth, houseDepth/2, 0.15);

/* ===================== Kamin ===================== */   
const chimney = new THREE.Mesh(
    new THREE.BoxGeometry(1, 3, 1),
    matWall
);
chimney.position.set(-4, houseHeight + 1.5, 2); // X,Y,Z nach Wunsch
scene.add(chimney);

    
/* ===================== Terrasse ===================== */
const terrace = new THREE.Mesh(
    new THREE.BoxGeometry(10, 0.15, 4),
    new THREE.MeshStandardMaterial({color:0xd2b48c})
);
terrace.rotation.x = Math.PI / 2;
terrace.position.set(10,0.075,0); // vorne an Haus anschließen
scene.add(terrace);

/* ===================== Pool ===================== */
const pool = new THREE.Mesh(
    new THREE.BoxGeometry(10, 0.5, 6),
    new THREE.MeshStandardMaterial({color:0x4da6ff, transparent:true, opacity:0.7})
);
pool.rotation.x = Math.PI / 2;
pool.position.set(20, -0.25, 0); // vor der Terrasse
scene.add(pool);    
    
/* ===================== Bäume ===================== */
function tree(x,z){
    const t = new THREE.Mesh(new THREE.CylinderGeometry(0.25,0.25,1.5), new THREE.MeshStandardMaterial({color:0x5a3b1e}));
    t.position.set(x,0.75,z);
    scene.add(t);
    const c = new THREE.Mesh(new THREE.SphereGeometry(1), new THREE.MeshStandardMaterial({color:0x2f7d32}));
    c.position.set(x,2.2,z);
    scene.add(c);
}
tree(-15,-7);
tree(15,-7);
tree(-15,7);
tree(15,7);


/* ===================== Buttons ===================== */
    
<style>
  button {
    position: fixed;
    left: 20px;
    padding: 10px 16px;
    font-size: 14px;
    cursor: pointer;
    z-index: 1000;
  }

  #btnIndex {
    top: 20px;
  }

  #btnBack {
    top: 70px;
  }

  #btnHome {
    top: 120px;
  }
</style>   

<button id="btnIndex">Zurück zu Index</button>
<button id="btnBack">Eine Seite zurück</button>
<button id="btnHome">Zur Startseite (hart)</button>

    
// Zurück zu index.html
document.getElementById("btnIndex").addEventListener("click", () => {
  window.location.href = "index.html";
});

// Browser-Zurück (history)
document.getElementById("btnBack").addEventListener("click", () => {
  history.back();
});

// Harte Navigation (erzwingt Reload von index.html)
document.getElementById("btnHome").addEventListener("click", () => {
  window.location.assign("index.html");
});


    
/* ===================== Maussteuerung ===================== */
let isMouseDown = false;
let mouseX = 0;
let targetRotation = 0;
let targetRotationOnMouseDown = 0;

window.addEventListener('mousedown', (event)=>{
    isMouseDown = true;
    mouseX = event.clientX;
    targetRotationOnMouseDown = targetRotation;
});

window.addEventListener('mousemove', (event)=>{
    if (isMouseDown){
        const deltaX = event.clientX - mouseX;
        targetRotation = targetRotationOnMouseDown + deltaX*0.005;
    }
});

window.addEventListener('mouseup', ()=>{ isMouseDown=false; });

window.addEventListener('wheel', (event)=>{
    camera.position.y -= event.deltaY*0.01;
    camera.position.y = Math.max(5, Math.min(50, camera.position.y));
});

/* ===================== Animation ===================== */
function animate(){
    requestAnimationFrame(animate);
    const radius = 30;
    camera.position.x = radius * Math.cos(targetRotation);
    camera.position.z = radius * Math.sin(targetRotation);
    camera.lookAt(0,1.5,0);
    renderer.render(scene,camera);
}
animate();

/* ===================== Fensteranpassung bei Resize ===================== */
window.addEventListener("resize",()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth,innerHeight);
});
</script>

</body>
</html>
