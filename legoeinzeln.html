<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>3D Bungalow – mit Pool und Garten  </title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
      
<style>
body { margin:0; background:#eef2f3; font-family:system-ui; overflow:hidden; }
#container { width:100vw; height:100vh; }
body { margin:0; overflow:hidden; }

button {position: fixed; left: 20px; padding: 8px 14px; z-index: 10; cursor: pointer;}

#btnIndex { top: 20px; }
#btnBack  { top: 60px; }
#btnHome  { top: 100px; } 
</style>
      
</head>
<body>

<button id="btnIndex">Startseite</button>
<button id="btnBack">Zurück</button>
<button id="btnHome">Home</button>

<div id="container"></div>
   
    
<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.158/build/three.module.js";

/* ===================== Grundwerte ===================== */
const houseWidth  = 12;
const houseDepth  = 12;
const houseHeight = 3;
const axes = new THREE.AxesHelper(10);

const container = document.getElementById("container");
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xcce6ff);
scene.add(axes);

const houseGroup = new THREE.Group();
scene.add(houseGroup);


const houseOffsetX = 5;
const houseOffsetZ = 4;
houseGroup.position.set(houseOffsetX, 0, houseOffsetZ);

/* ===================== Kamera ===================== */
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 500);
camera.position.set(30, 18, 30);

/* ===================== Renderer ===================== */
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
container.appendChild(renderer.domElement);

/* ===================== Licht ===================== */
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const sun = new THREE.DirectionalLight(0xffffff, 1);
sun.position.set(50,100,50);
scene.add(sun);

/* ===================== Materialien ===================== */
const matGround = new THREE.MeshStandardMaterial({color:0x7fa86c});
const matWall   = new THREE.MeshStandardMaterial({color:0xc7a17a});
const matRoof   = new THREE.MeshStandardMaterial({color:0x8b3e2f});
const matGlass  = new THREE.MeshStandardMaterial({color:0x99ccff, transparent:true, opacity:0.6});
const matWood   = new THREE.MeshStandardMaterial({color:0x4a2e1b});

/* ===================== Grundstück ===================== */
const ground = new THREE.Mesh(new THREE.PlaneGeometry(40,20), matGround);
ground.rotation.x = -Math.PI/2;
ground.position.set(20, 0, 10); // Mittelpunkt bei positivem Raum
scene.add(ground);

/* ===================== Wände ===================== */
function wallBlocksArray(x0,z0,w,d,h){
    const blocks = [];
    const size = 0.4;
    const gap = 0.03;
    for(let x=0; x<w; x+=size+gap){
        for(let y=0; y<h; y+=size+gap){
            for(let z=0; z<d; z+=size+gap){
                const b = new THREE.Mesh(
                    new THREE.BoxGeometry(size,size,size),
                    matWall
                );
                b.position.set(x0 + x + size/2, y + size/2, z0 + z + size/2);
                blocks.push(b);
            }
        }
    }
    return blocks;
}

// Wände
const wallFrontArray = wallBlocksArray(0, 0, houseWidth, 0.4, houseHeight);
const wallBackArray  = wallBlocksArray(0, houseDepth-0.4, houseWidth, 0.4, houseHeight);
const wallLeftArray  = wallBlocksArray(0, 0, 0.4, houseDepth, houseHeight);
const wallRightArray = wallBlocksArray(houseWidth-0.4, 0, 0.4, houseDepth, houseHeight);

// nacheinander hinzufügen
let arrays = [wallFrontArray, wallBackArray, wallLeftArray, wallRightArray];
let arrayIndex = 0;
function addNextWall(){
    if(arrayIndex < arrays.length){
        let blocks = arrays[arrayIndex];
        let i=0;
        function addBlock(){
            if(i<blocks.length){
                houseGroup.add(blocks[i]);
                i++;
                setTimeout(addBlock,10);
            } else {
                arrayIndex++;
                addNextWall();
            }
        }
        addBlock();
    }
}
addNextWall();


/* ===================== Fenster ===================== */
function createWindow(xStart, yStart, zStart, width, height, depth=0.2){
    const group = new THREE.Group();
    const size=0.3, gap=0.05;
    for(let x=0;x<width;x+=size+gap){
        for(let y=0;y<height;y+=size+gap){
            const block = new THREE.Mesh(new THREE.BoxGeometry(size,size,depth), matGlass);
            block.position.set(xStart+x+size/2, yStart+y+size/2, zStart);
            group.add(block);
        }
    }
    houseGroup.add(group);
}

// vorne links und rechts
createWindow(2, 1.2, 0, 2.4, 1.6);
createWindow(7.6, 1.2, 0, 2.4, 1.6);

/* ===================== Glastür ===================== */
function createSlidingDoor(xStart, yStart, zStart, width, height, depth=0.2){
    const group = new THREE.Group();
    const size=0.4, gap=0.05;
    for(let x=0;x<width;x+=size+gap){
        for(let y=0;y<height;y+=size+gap){
            const block = new THREE.Mesh(new THREE.BoxGeometry(size,size,depth), matGlass);
            block.position.set(xStart+x+size/2, yStart+y+size/2, zStart);
            group.add(block);
        }
    }
    return group;
}

// Glastür an Längsseite (rechte Seite)
const slidingDoor = createSlidingDoor(0, 0.3, 3, 2.2, 4, 0.2); // X=0, Z=3
slidingDoor.rotation.x = -Math.PI/2; // um 90° drehen
slidingDoor.position.set(houseWidth, 0.3, houseDepth/2); // rechts ans Haus, mittig Z
houseGroup.add(slidingDoor);



    
/* ===================== Tür ===================== */
const door = new THREE.Mesh(new THREE.BoxGeometry(1.8,2.3,0.2), matWood);
door.position.set(houseWidth/2, 1.15, 0); // vorne mittig
houseGroup.add(door);
      

/* ===================== Walmdach ===================== */
function roofSlopeAllSides(width, depth, slope) {
    const size = 0.4;   // Dachblockgröße
    const gap = 0.15;
    const yBase = houseHeight; // Start Y = Wandoberkante

    // VORNE (Z=0)
    const frontRoof = new THREE.Group();
    for (let x = 0; x < width; x += size + gap) {
        for (let z = 0; z < depth/2; z += size + gap) {
            const y = yBase + z * slope;
            const tile = new THREE.Mesh(
                new THREE.BoxGeometry(size, size*0.4, size),
                matRoof
            );
            tile.position.set(x + size/2, y, z + size/2);
            frontRoof.add(tile);
        }
    }
    houseGroup.add(frontRoof);

    // HINTEN (Z = depth - 0.5)
    const backRoof = new THREE.Group();
    for (let x = 0; x < width; x += size + gap) {
        for (let z = 0; z < depth/2; z += size + gap) {
            const y = yBase + z * slope;
            const tile = new THREE.Mesh(
                new THREE.BoxGeometry(size, size*0.4, size),
                matRoof
            );
            tile.position.set(x + size/2, y, depth - z - size/2);
            backRoof.add(tile);
        }
    }
    houseGroup.add(backRoof);
}

// Dach aufsetzen
roofSlopeAllSides(houseWidth, houseDepth, 0.15);


/* ===================== Kamin ===================== */
const chimney = new THREE.Mesh(new THREE.BoxGeometry(0.8,2,0.8), matWall);
chimney.position.set(2, houseHeight+1, 2); // relativ zu houseGroup
houseGroup.add(chimney);
    
/* ===================== Terrasse ===================== */
const terrace = new THREE.Mesh(
    new THREE.BoxGeometry(5, 0.15, 10), // X und Z getauscht für Längsseite
    new THREE.MeshStandardMaterial({color:0xd2b48c})
);
terrace.position.set(houseWidth + 2.5, 0.075, houseDepth/2); // rechts an Haus-Längsseite
houseGroup.add(terrace);


/* ===================== Pool ===================== */
const pool = new THREE.Mesh(
    new THREE.BoxGeometry(10, 0.5, 10), // X und Z getauscht
    new THREE.MeshStandardMaterial({color:0x4da6ff, transparent:true, opacity:0.7})
);
pool.position.set(houseWidth + 5.5, -0.25, houseDepth/2); // neben Terrasse
houseGroup.add(pool);

    
/* ===================== Garten-Gruppe für gesamtes Grundstück ===================== */
const gardenGroup = new THREE.Group();
houseGroup.add(gardenGroup); // Garten gehört zum Haus, verschiebbar

const plotWidth = 40;
const plotDepth = 20;
const houseBuffer = 2; // Abstand vom Haus zu den Pflanzen

/* ===================== Bäume ===================== */
function treePlot(x, z, height = 1.5, radius = 0.25, crownRadius = 1) {
    const t = new THREE.Mesh(
        new THREE.CylinderGeometry(radius, radius, height),
        new THREE.MeshStandardMaterial({color:0x5a3b1e})
    );
    t.position.set(x, height/2, z);
    gardenGroup.add(t);

    const c = new THREE.Mesh(
        new THREE.SphereGeometry(crownRadius, 16, 16),
        new THREE.MeshStandardMaterial({color:0x2f7d32})
    );
    c.position.set(x, height + crownRadius*0.7, z);
    gardenGroup.add(c);
}

// Bäume in den vier Ecken
treePlot(1, 1, 3, 0.35, 2);
treePlot(plotWidth - 1, 1, 3, 0.35, 2);
treePlot(1, plotDepth - 1, 3, 0.35, 2);
treePlot(plotWidth - 1, plotDepth - 1, 3, 0.35, 2);

// Mittige Bäume an den Seiten (leicht versetzt)
treePlot(plotWidth/2, 1, 2.5, 0.3, 1.5);
treePlot(plotWidth/2, plotDepth - 1, 2.5, 0.3, 1.5);
treePlot(1, plotDepth/2, 2.5, 0.3, 1.5);
treePlot(plotWidth - 1, plotDepth/2, 2.5, 0.3, 1.5);

/* ===================== Blumen ===================== */
function flowerPlot(x, z, height = 0.3, radius = 0.2, color = 0xff5555) {
    const f = new THREE.Mesh(
        new THREE.CylinderGeometry(radius, radius, height),
        new THREE.MeshStandardMaterial({color: color})
    );
    f.position.set(x, height/2, z);
    gardenGroup.add(f);
}

// Einige Blumen verteilt im Garten
for(let i=0; i<15; i++){
    const x = houseBuffer + Math.random() * (plotWidth - 2*houseBuffer);
    const z = houseBuffer + Math.random() * (plotDepth - 2*houseBuffer);
    const colors = [0xff4444, 0xffcc44, 0xff88ff, 0xffff44, 0x44ff44, 0x44ccff];
    const color = colors[Math.floor(Math.random()*colors.length)];
    flowerPlot(x, z, 0.25 + Math.random()*0.1, 0.15 + Math.random()*0.05, color);
}

/* ===================== Zaun ===================== */
function fencePlot(x0, z0, width, depth, height = 1.2, postWidth = 0.1, spacing = 0.5){
    const material = new THREE.MeshStandardMaterial({color:0x8b5a2b});

    // X-Richtung vorne/hinten
    for(let x = x0; x <= x0 + width; x += spacing){
        const postF = new THREE.Mesh(new THREE.BoxGeometry(postWidth, height, postWidth), material);
        postF.position.set(x, height/2, z0);
        gardenGroup.add(postF);

        const postB = new THREE.Mesh(new THREE.BoxGeometry(postWidth, height, postWidth), material);
        postB.position.set(x, height/2, z0 + depth);
        gardenGroup.add(postB);
    }

    // Z-Richtung links/rechts
    for(let z = z0; z <= z0 + depth; z += spacing){
        const postL = new THREE.Mesh(new THREE.BoxGeometry(postWidth, height, postWidth), material);
        postL.position.set(x0, height/2, z);
        gardenGroup.add(postL);

        const postR = new THREE.Mesh(new THREE.BoxGeometry(postWidth, height, postWidth), material);
        postR.position.set(x0 + width, height/2, z);
        gardenGroup.add(postR);
    }
}

// Zaun direkt an Grundstücksgrenzen
fencePlot(0, 0, plotWidth, plotDepth);

    
/* ===================== Maussteuerung ===================== */
let isMouseDown = false;
let mouseX = 0;
let targetRotation = 0;
let targetRotationOnMouseDown = 0;

window.addEventListener('mousedown', (event)=>{
    isMouseDown = true;
    mouseX = event.clientX;
    targetRotationOnMouseDown = targetRotation;
});

window.addEventListener('mousemove', (event)=>{
    if (isMouseDown){
        const deltaX = event.clientX - mouseX;
        targetRotation = targetRotationOnMouseDown + deltaX*0.005;
    }
});

window.addEventListener('mouseup', ()=>{ isMouseDown=false; });

window.addEventListener('wheel', (event)=>{
    camera.position.y -= event.deltaY*0.01;
    camera.position.y = Math.max(5, Math.min(50, camera.position.y));
});

/* ===================== Animation ===================== */
function animate(){
    requestAnimationFrame(animate);
    const radius = 30;
    camera.position.x = radius * Math.cos(targetRotation);
    camera.position.z = radius * Math.sin(targetRotation);
    camera.lookAt(houseOffsetX + houseWidth/2, 1.5, houseOffsetZ + houseDepth/2);
    renderer.render(scene,camera);
}
animate();

/* BUTTON EVENTS – GANZ UNTEN */
document.getElementById("btnIndex").onclick = () => {
  window.location.href = "index.html";
};

document.getElementById("btnBack").onclick = () => {
  history.back();
};

document.getElementById("btnHome").onclick = () => {
  window.location.assign("index.html");
};

/* ===================== Fensteranpassung bei Resize ===================== */
window.addEventListener("resize",()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth,innerHeight);
});
</script>

</body>
</html>
