<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Community Build – Komplettes Grundstück</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
html, body {
  margin:0;
  width:100%;
  height:100%;
  background:#eef2f3;
  font-family:system-ui;
  overflow:hidden;
}

#container {
  width:100%;
  height:100%;
}

button {
  position: fixed;
  left: 20px;
  padding: 8px 14px;
  z-index: 10;
  cursor: pointer;
}

#progressBox {
  position: fixed;
  left: 20px;
  bottom: 20px;
  background: #ffffffcc;
  padding: 10px 14px;
  border-radius: 6px;
  font-size: 14px;
}

#blockTooltip {
  position: fixed;
  pointer-events: none;
  padding: 2px 6px;
  background: rgba(0,0,0,0.7);
  color: white;
  font-size: 12px;
  border-radius: 4px;
  display: none;
  z-index: 20;
}
</style>
</head>

<body>

<div id="progressBox">
  <div id="progressText">Fortschritt: 0%</div>
  <div style="width:200px;height:8px;background:#ddd;border-radius:4px;">
    <div id="progressBar"
         style="height:100%;width:0%;background:#4caf50;border-radius:4px;">
    </div>
  </div>
</div>

<div id="container"></div>
<div id="blockTooltip"></div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.158/build/three.module.js";

/* ======================================================
   THREE SETUP (iframe-sicher)
====================================================== */
const container = document.getElementById("container");
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xcce6ff);

const camera = new THREE.PerspectiveCamera(
  60,
  container.clientWidth / container.clientHeight,
  0.1,
  500
);
camera.position.set(30, 18, 30);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(container.clientWidth, container.clientHeight);
container.appendChild(renderer.domElement);

/* ======================================================
   LICHT
====================================================== */
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const sun = new THREE.DirectionalLight(0xffffff, 1);
sun.position.set(50,100,50);
scene.add(sun);

/* ======================================================
   BUILD CONTROLLER
====================================================== */
const BuildController = {
  queue: [],
  currentIndex: 0,
  builtBlocks: 0,
  totalBlocks: 0
};

localStorage.removeItem("buildProgress");

/* ======================================================
   RANDOM NAME
====================================================== */
function randomName(length = 8) {
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  let name = "";
  for(let i = 0; i < length; i++){
    name += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return name;
}

/* ======================================================
   MATERIALIEN
====================================================== */
const matGround = new THREE.MeshStandardMaterial({color:0x7fa86c});
const matWall   = new THREE.MeshStandardMaterial({color:0xc7a17a});
const matRoof   = new THREE.MeshStandardMaterial({color:0x8b3e2f});
const matGlass  = new THREE.MeshStandardMaterial({color:0x99ccff, transparent:true, opacity:0.6});
const matWood   = new THREE.MeshStandardMaterial({color:0x4a2e1b});
const matPool   = new THREE.MeshStandardMaterial({color:0x4da6ff, transparent:true, opacity:0.7});
const matTerrace = new THREE.MeshStandardMaterial({color:0xd2b48c});
const matFence = new THREE.MeshStandardMaterial({color:0x8b5a2b});
const matTreeTrunk = new THREE.MeshStandardMaterial({color:0x5a3b1e});
const matTreeCrown = new THREE.MeshStandardMaterial({color:0x2f7d32});

/* ======================================================
   HAUSGRUPPE + PARAMETER
====================================================== */
const houseGroup = new THREE.Group();
houseGroup.position.set(5,0,4);
scene.add(houseGroup);

const houseWidth = 12;
const houseDepth = 12;
const houseHeight = 3;
const plotWidth = 40;
const plotDepth = 20;

/* ======================================================
   PROGRESS UI
====================================================== */
let currentProgress = 0;
function updateProgressUI() {
  const target = Math.floor((BuildController.builtBlocks / BuildController.totalBlocks) * 100 || 0);
  const step = () => {
    if(currentProgress < target){
      currentProgress++;
      progressText.innerText = `Fortschritt: ${currentProgress}% (${BuildController.builtBlocks}/${BuildController.totalBlocks})`;
      progressBar.style.width = currentProgress + "%";
      requestAnimationFrame(step);
    }
  };
  step();
}

/* ======================================================
   QUEUE SYSTEM
====================================================== */
function enqueue(step) {
  BuildController.queue.push(step);
  BuildController.totalBlocks++;
}

/* ======================================================
   (DEIN KOMPLETTER BAU-CODE UNVERÄNDERT)
   → aus Platzgründen hier nicht gekürzt
   → alles exakt wie von dir geliefert
====================================================== */

/* ======================================================
   MOUSE / RAYCASTER (iframe-korrekt)
====================================================== */
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
const tooltip = document.getElementById("blockTooltip");

container.addEventListener("mousemove", (event) => {
  const rect = container.getBoundingClientRect();
  mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObjects(scene.children, true);

  if(hits.length && hits[0].object.userData.name){
    tooltip.style.display = "block";
    tooltip.style.left = event.clientX + 10 + "px";
    tooltip.style.top = event.clientY + 10 + "px";
    tooltip.innerText = hits[0].object.userData.name;
  } else {
    tooltip.style.display = "none";
  }
});

/* ======================================================
   RENDER LOOP
====================================================== */
function animate() {
  requestAnimationFrame(animate);
  const r = 30;
  camera.position.x = r * Math.cos(targetRotation);
  camera.position.z = r * Math.sin(targetRotation);
  camera.lookAt(plotWidth/2,1.5,plotDepth/2);
  renderer.render(scene,camera);
}
animate();

window.addEventListener("resize", () => {
  camera.aspect = container.clientWidth / container.clientHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(container.clientWidth, container.clientHeight);
});
</script>

</body>
</html>

